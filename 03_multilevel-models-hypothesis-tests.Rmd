---
title: "Hypothesis tests — HPT (Czech data)"
subtitle: "Multilevel models for H1–H2"
author: "HPT and Extremism project"
date: "`r format(Sys.Date())`"
output:
  pdf_document:
    latex_engine: xelatex
    number_sections: true
    toc: true
    toc_depth: 3
fontsize: 10pt
geometry:
  - landscape
  - margin=0.7in

header-includes:
  - \usepackage{booktabs}
  - \usepackage{longtable}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{pdflscape}
  - \usepackage{threeparttable}
  - \usepackage{threeparttablex}
  - \usepackage[normalem]{ulem}
  - \usepackage{makecell}
  - \setlength{\LTcapwidth}{\textwidth}
---

# 1. Purpose and hypotheses

This document runs the **main confirmatory analyses** for:

* **H1.** Higher right‐authoritarian / pro-Nazi attitudes predict **higher HPT scores** on the original instrument (risk of ideological contamination). Predictors: FR-LF-mini (total or RD/NS facets) and KSA-3.
* **H2.** The H1 effect **persists controlling** for prior knowledge (KN total) and social desirability (SDR-5).

Notes on constructs and scoring:

* HPT instrument and subscores (POP, ROA, CONT) follow Hartmann & Hasselhorn / Huijgen et al. For this file we use **HPT total, CONT, POP** as DVs. (In our dataset, higher is coded as “fits Hannes’s situation better” across items; thus **higher CONT** means more contextualized alignment; **higher POP** reflects stronger endorsement of the presentism-trigger statements after our recoding.)
* FR-LF-mini uses **RD1–RD3** (right-dictatorship) and **NS1–NS3** (Nazi relativization) with robust reliability and a validated 6-dimension parent scale. We analyze **total** and the **RD/NS facets**.
* KSA-3 (9 items; aggression, submission, conventionalism) is included as a convergent authoritarian predictor. (Registered.)

# 2. Data, variables, and preprocessing

We expect either `normalised_responses_<DATE>.RData` or `.xlsx` in the project root. Variable names match the codebook.

```{r,setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
set.seed(1234)
```

```{r,packages}
# Core
library(tidyverse)
library(readxl)
library(janitor)
# Models + tables
library(lme4)
library(lmerTest)
library(performance)
library(effectsize)
library(broom.mixed)
library(modelsummary)
library(glue)

library(kableExtra)
options(
    modelsummary_format = "latex",
    modelsummary_factory_latex = "kableExtra"
)
```

```{r,load-data}
# Load the dataset created in 00_data-preparation
load("normalised_responses.RData")
stopifnot(exists("normalised_responses"))

dat_raw <- normalised_responses

dat_raw <- janitor::clean_names(dat_raw)
```


```{r,score-constructs}
# ---- Knowledge ----
kn_items <- paste0("kn", 1:6)

dat <- dat_raw |>
  mutate(
    # across() returns a data frame of the selected columns; rowSums works on that
    kn_total = rowSums(across(all_of(kn_items)), na.rm = TRUE)
  )

# ---- HPT ----
pop_items   <- paste0("pop", 1:3)
cont_items  <- paste0("cont", 1:3)
roa_items   <- paste0("roa", 1:3)

dat <- dat |>
  mutate(
    hpt_pop   = rowMeans(across(all_of(pop_items)),  na.rm = TRUE),
    hpt_cont  = rowMeans(across(all_of(cont_items)), na.rm = TRUE),
    hpt_roa   = rowMeans(across(all_of(roa_items)),  na.rm = TRUE),
    hpt_total = rowMeans(cbind(hpt_pop, hpt_cont, hpt_roa), na.rm = TRUE)
  )

# ---- FR-LF mini ----
rd_items <- paste0("rd", 1:3)
ns_items <- paste0("ns", 1:3)

dat <- dat |>
  mutate(
    frlf_rd  = rowMeans(across(all_of(rd_items)), na.rm = TRUE),
    frlf_ns  = rowMeans(across(all_of(ns_items)), na.rm = TRUE),
    frlf_tot = rowMeans(cbind(frlf_rd, frlf_ns),  na.rm = TRUE)
  )

# ---- KSA-3 ----
a_items   <- paste0("a", 1:3)
u_items   <- paste0("u", 1:3)
k_items   <- paste0("k", 1:3)
ksa_items <- c(a_items, u_items, k_items)

dat <- dat |>
  mutate(
    ksa3_a   = rowMeans(across(all_of(a_items)),   na.rm = TRUE),
    ksa3_u   = rowMeans(across(all_of(u_items)),   na.rm = TRUE),
    ksa3_k   = rowMeans(across(all_of(k_items)),   na.rm = TRUE),
    ksa3_tot = rowMeans(across(all_of(ksa_items)), na.rm = TRUE)
  )

# ---- SDR-5 ----
# (SDR2–SDR4 already reversed upstream)
sdr_items <- paste0("sdr", 1:5)

dat <- dat |>
  mutate(
    sdr5_tot = rowMeans(across(all_of(sdr_items)), na.rm = TRUE)
  )

# ---- Clustering factor ----
cluster_var <- dplyr::case_when(
  "class_label" %in% names(dat) ~ "class_label",
  "class"       %in% names(dat) ~ "class",
  TRUE ~ NA_character_
)
if (is.na(cluster_var)) stop("No class cluster variable found (expected `class_label` or `class`).")
dat[[cluster_var]] <- as.factor(dat[[cluster_var]])
```

```{r,standardise}
# Z-standardise continuous predictors (for comparability) and outcomes (optional)
z <- function(x) as.numeric(scale(x))

dat <- dat |>
  mutate(
    z_hpt_total = z(hpt_total),
    z_hpt_cont  = z(hpt_cont),
    z_hpt_pop   = z(hpt_pop),

    z_frlf_tot = z(frlf_tot),
    z_frlf_rd  = z(frlf_rd),
    z_frlf_ns  = z(frlf_ns),

    z_ksa3_tot = z(ksa3_tot),

    z_kn_total = z(kn_total),
    z_sdr5_tot = z(sdr5_tot)
  ) |>
  drop_na(!!sym(cluster_var))   # must have cluster id
```

# 3. Model plan

We estimate **random‐intercept multilevel models** (students nested in classes). For each DV:

* **Base (FR-LF total):**
  `DV ~ z_frlf_tot + z_ksa3_tot + z_kn_total + z_sdr5_tot + (1 | class)`
* **Facet (RD/NS):**
  `DV ~ z_frlf_rd + z_frlf_ns + z_ksa3_tot + z_kn_total + z_sdr5_tot + (1 | class)`
* **Interaction (if preregistered):**
  `DV ~ z_frlf_tot * z_kn_total + z_ksa3_tot + z_sdr5_tot + (1 | class)`

DVs: `z_hpt_total`, `z_hpt_cont`, `z_hpt_pop`.

Interpretation (fixed effects): positive $\beta$ means **higher predictor → higher DV** (in SD units). For **H1–H2**, the key test is **FR-LF coefficients** (or RD/NS) remaining positive and significant **after controls**.

```{r,fit-models}
dv_list <- c("z_hpt_total","z_hpt_cont","z_hpt_pop")

fits <- list()

for (dv in dv_list) {

  # Build formulas INSIDE the loop (so {dv} exists when glue runs)
  form_base  <- as.formula(
    glue("{dv} ~ z_frlf_tot + z_ksa3_tot + z_kn_total + z_sdr5_tot + (1 | {cluster_var})")
  )

  form_facet <- as.formula(
    glue("{dv} ~ z_frlf_rd + z_frlf_ns + z_ksa3_tot + z_kn_total + z_sdr5_tot + (1 | {cluster_var})")
  )

  form_int   <- as.formula(
    glue("{dv} ~ z_frlf_tot * z_kn_total + z_ksa3_tot + z_sdr5_tot + (1 | {cluster_var})")
  )

  # Fit models
  m_base  <- lmer(form_base,  data = dat)
  m_facet <- lmer(form_facet, data = dat)
  m_int   <- lmer(form_int,   data = dat)

  fits[[dv]] <- list(
    base  = m_base,
    facet = m_facet,
    int   = m_int
  )
}
```

```{r,model-summaries}
# Show standard errors in parentheses; alternatives include {t}, {p.value}, etc.
msummary(
  list(
    "HPT total — Base"  = fits$z_hpt_total$base,
    "HPT total — Facet" = fits$z_hpt_total$facet,
    "HPT total — Int."  = fits$z_hpt_total$int
  ),
  statistic = "({std.error})",
  gof_omit = "IC|Log|AIC|BIC",
  stars = TRUE
)

msummary(
  list(
    "CONT — Base"  = fits$z_hpt_cont$base,
    "CONT — Facet" = fits$z_hpt_cont$facet,
    "CONT — Int."  = fits$z_hpt_cont$int
  ),
  statistic = "({std.error})",
  gof_omit = "IC|Log|AIC|BIC",
  stars = TRUE
)

msummary(
  list(
    "POP — Base"  = fits$z_hpt_pop$base,
    "POP — Facet" = fits$z_hpt_pop$facet,
    "POP — Int."  = fits$z_hpt_pop$int
  ),
  statistic = "({std.error})",
  gof_omit = "IC|Log|AIC|BIC",
  stars = TRUE
)
```

```{r,fit-metrics}
# Robust extractors so we ALWAYS return a single-row data.frame
`%||%` <- function(a, b) if (!is.null(a) && length(a) > 0) a else b

collect_metrics <- function(m) {
  # ICC (allow for API differences)
  icc_val <- tryCatch({
    ic <- performance::icc(m)
    as.numeric(
      ic$ICC_adjusted %||% ic$ICC %||% ic$ICC_conditional %||% NA_real_
    )
  }, error = function(e) NA_real_)

  # R2 (prefer Nakagawa; fallbacks to older names)
  r2m <- r2c <- NA_real_
  try({
    r2o <- performance::r2_nakagawa(m)
    r2m <- as.numeric(r2o$R2_marginal %||% r2o$R2m %||% NA_real_)
    r2c <- as.numeric(r2o$R2_conditional %||% r2o$R2c %||% NA_real_)
  }, silent = TRUE)

  data.frame(ICC = icc_val, R2_m = r2m, R2_c = r2c, check.names = FALSE)
}

metrics <- dplyr::bind_rows(
  list(
    `HPT total — Base`  = collect_metrics(fits$z_hpt_total$base),
    `HPT total — Facet` = collect_metrics(fits$z_hpt_total$facet),
    `HPT total — Int.`  = collect_metrics(fits$z_hpt_total$int),
    `CONT — Base`       = collect_metrics(fits$z_hpt_cont$base),
    `CONT — Facet`      = collect_metrics(fits$z_hpt_cont$facet),
    `CONT — Int.`       = collect_metrics(fits$z_hpt_cont$int),
    `POP — Base`        = collect_metrics(fits$z_hpt_pop$base),
    `POP — Facet`       = collect_metrics(fits$z_hpt_pop$facet),
    `POP — Int.`        = collect_metrics(fits$z_hpt_pop$int)
  ),
  .id = "Model"
)

knitr::kable(metrics, digits = 3, caption = "Model fit and clustering (ICC, $R^2$).")
```


```{r,tidy-effects}
# Extract tidy tables for inference and interpretation sections
tidy_all <- function(lst, label) {
  bind_rows(
    broom.mixed::tidy(lst$base,  effects="fixed", conf.int=TRUE) |> mutate(spec="Base"),
    broom.mixed::tidy(lst$facet, effects="fixed", conf.int=TRUE) |> mutate(spec="Facet"),
    broom.mixed::tidy(lst$int,   effects="fixed", conf.int=TRUE) |> mutate(spec="Interaction")
  ) |>
    filter(term != "(Intercept)") |>
    mutate(dv = label)
}

tidy_tbl <- bind_rows(
  tidy_all(fits$z_hpt_total, "HPT total"),
  tidy_all(fits$z_hpt_cont,  "CONT"),
  tidy_all(fits$z_hpt_pop,   "POP")
)

knitr::kable(
  tidy_tbl |> select(dv, spec, term, estimate, conf.low, conf.high, p.value),
  digits = 3,
  caption = "Fixed effects (standardized coefficients)."
)
```

# 4. Results — decision rules

Interpret **only the preregistered tests**:

* **H1 supported** if the coefficient for **FR-LF** (either `z_frlf_tot` in Base/Int. or `z_frlf_rd`/`z_frlf_ns` in Facet) is **$>$ 0 and $p < .05$** for **HPT total** and/or **CONT**.
* **H2 supported** if the same holds **after** adding controls (**KN**, **SDR-5**) and **KSA-3** (already included), and — if preregistered — the **FR-LF × KN** interaction is **not necessary** for the main effect to persist (or, if hypothesized, is significant in the expected direction).

**Reading POP.** Given our recoding (1–4 “fit”), higher **POP** here reflects stronger agreement that the presentism-trigger statements “fit” Hannes. In the original instrument, POP and CONT came out as a single factor vs. ROA in CFA, and item wording can trip respondents; interpret POP cautiously and triangulate with CONT.

# 5. Brief interpretation guide (for the write-up)

* **Effect size:** Coefficients are **standardized** ($\beta$). Values around 0.10 are small, 0.20–0.30 moderate for individual-level predictors in multilevel models; report 95% CIs.
* **Clustering:** Report **ICC** to show class-level variance.
* **Model fit:** Report marginal and conditional $R^2$ and compare Base vs. Facet vs. Interaction.
* **Substantive meaning:** A **positive FR-LF** effect on **HPT total / CONT** suggests that ideological affinity **elevates apparent contextualization**, consistent with the contamination concern. Cite the HPT literature and the FR-LF validation when interpreting.
* **Controls:** If FR-LF remains significant after **KN** and **SDR-5**, state that results are **not explained** by prior knowledge or social desirability (per H2).

# 6. Transparency and provenance

* **Instrument provenance.** HPT instrument and subscale logic follow Hartmann & Hasselhorn / Huijgen et al. (contextualization vs. presentism; known POP/CONT factor behavior; potential item-level ambiguities).
* **FR-LF-mini.** Items RD1–3 and NS1–3 originate from the Leipzig FR-LF, which shows a stable 6-factor structure and excellent internal consistency in representative samples.
* **Analysis plan.** This file implements the Stage 1 snapshot plan (multilevel regressions; DVs: HPT total, CONT, POP; predictors: FR-LF, KSA-3; controls: KN, SDR-5; class clustering).
* **Variable names and coding** are taken from the project codebook to ensure reproducibility.

# 7. Session info

```{r,session-info}
sessionInfo()
```

---

### Minimal reporting template (paste into manuscript)

* **Model:** Random-intercept LMM (classes).
* **DV:** HPT total (z); robustness for CONT (z) and POP (z).
* **Predictors:** FR-LF total (z) or RD/NS facets (z); KSA-3 total (z); controls KN (z), SDR-5 (z).
* **Key result:** $\beta_{\text{FR-LF}}=\ldots$, 95% CI $[\ldots,\ldots]$, $p=\ldots$; ICC = $\ldots$; $R^2_m=\ldots$, $R^2_c=\ldots$.
* **Decision:** H1 … / H2 … (per criteria above).

*References for context*: Huijgen et al. on HPT structure and presentism risks; FR-LF validation and dimensionality; Stage 1 snapshot for analytic plan; project codebook for variables.